import * as web3 from "@solana/web3.js";
import BN from "bn.js";
import HawkAPI from "../src";

const client = new HawkAPI('http://localhost:5001');
const TIMEOUT = 30_000;

describe('Health Endpoints', () => {
  it ('GET /health', async () => {
    const result: any = await client.health.health();
    expect(result.status).toBe(200);
    for (const key in result.services) {
      expect(result.services[key]).toBe('OK');
    }
  });
});

describe('General Endpoints', () => {
  it ('GET /portfolio', async () => {
    const result = await client.general.portfolio({ wallet: 'Ga5jNBh26JHh9zyJcdm7vpyVWRgtKS2cLpNgEc5zBv8G' });
    expect(result.status).toBe(200);
    for (const poolId in result.data.pools) {
      if (result.data.pools[poolId] !== undefined) {
        for (const position of result.data.pools[poolId]) {
          expect(isPublicKey(position.positionAddress)).toBe(true); // Must be a valid public key
          expect(position.balances.length >= 0).toBe(true); // Must be a valid array
          expect(position.fees.length >= 0).toBe(true); // Must be a valid array
          expect(position.rewards.length >= 0).toBe(true); // Must be a valid array
          for (const balance of position.balances) {
            expect(isInteger(balance.amount)).toBe(true);
            expect(isPublicKey(balance.mint)).toBe(true);
          }
          for (const balance of position.fees) {
            expect(isInteger(balance.amount)).toBe(true);
            expect(isPublicKey(balance.mint)).toBe(true);
          }
          for (const balance of position.rewards) {
            expect(isInteger(balance.amount)).toBe(true);
            expect(isPublicKey(balance.mint)).toBe(true);
          }
        }
      }
    }
  }, TIMEOUT);

  it ('GET /pools', async () => {
    const result = await client.general.pools();
    expect(result.status).toBe(200);
    for (const poolId in result.data.pools) {
      if (result.data.pools[poolId] !== undefined) {
        for (const position of result.data.pools[poolId]) {
          expect(isPublicKey(position.positionAddress)).toBe(true); // Must be a valid public key
          expect(position.balances.length >= 0).toBe(true); // Must be a valid array
          expect(position.fees.length >= 0).toBe(true); // Must be a valid array
          expect(position.rewards.length >= 0).toBe(true); // Must be a valid array
          for (const balance of position.balances) {
            expect(isInteger(balance.amount)).toBe(true);
            expect(isPublicKey(balance.mint)).toBe(true);
          }
          for (const balance of position.fees) {
            expect(isInteger(balance.amount)).toBe(true);
            expect(isPublicKey(balance.mint)).toBe(true);
          }
          for (const balance of position.rewards) {
            expect(isInteger(balance.amount)).toBe(true);
            expect(isPublicKey(balance.mint)).toBe(true);
          }
        }
      }
    }
  }, TIMEOUT);
});
describe('Meteora Endpoints', () => {});
describe('Orca Endpoints', () => {});


// describe('Meteora DLMM', () => {
//   describe('createPositionAndDeposit', () => {
//     it('createPositionAndDeposit', async () => {
//       const positionKp = web3.Keypair.generate();
//       const position = positionKp.publicKey;
//       const userWalletKp = web3.Keypair.generate();
//       const userWallet = userWalletKp.publicKey;
//       const userPda = core.util.generateUserPda(userWallet);
//       const userTokenA = core.util.generateAta(userWallet, new web3.PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v')); // EPjF is USDC
//       const userTokenB = core.util.generateAta(userWallet, new web3.PublicKey('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB')); // Es9v is USDT
//       const userPdaTokenA = core.util.generateAta(userPda, new web3.PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v')); // EPjF is USDC
//       const userPdaTokenB = core.util.generateAta(userPda, new web3.PublicKey('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB')); // Es9v is USDT
//       // Mock the Connection class (generated by gpt)
//       jest.mock('@solana/web3.js', () => {
//         const originalModule = jest.requireActual('@solana/web3.js');
//         return {
//           __esModule: true,
//           ...originalModule,
//           Connection: jest.fn().mockImplementation(() => {
//             return {
//               getAccountInfo: jest.fn((pubkey) => {
//                 if (pubkey === userPda) {
//                   return Promise.resolve(null); // Return null for userPda
//                 }
//                 return originalModule.Connection.prototype.getAccountInfo.apply(this, pubkey);
//               }),
//               // Other methods of Connection...
//             };
//           }),
//         };
//       });
//       // Running our point of interest (createPositionAndDeposit)
//       const txs = await core.services.protocol.meteora.createPositionAndDeposit({
//         position,
//         pool: 'USDC-USDT',
//         userWallet,
//         totalXAmount: new BN(100000),
//         totalYAmount: new BN(100000),
//         binRange: {
//           lowerRange: -10,
//           upperRange: 20
//         },
//         distribution: "SPOT",
//       });
//       const firstIx = txs[0][0];
//       const secondIx = txs[0][1];
//       const thirdIx = txs[0][2];
//       // Checkpoint 1: Check idempotent create ata instructions (x and y token creation)
//       // More info: https://github.com/solana-labs/solana-program-library/blob/master/associated-token-account/program/src/processor.rs#L73
//       expect(firstIx.programId.toBase58()).toBe('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
//       expect(firstIx.keys[0].pubkey.toBase58()).toBe(userWallet.toBase58());
//       expect(firstIx.keys[1].pubkey.toBase58()).toBe(userPdaTokenA.toBase58());
//       expect(firstIx.keys[2].pubkey.toBase58()).toBe(userPda.toBase58());
//       expect(secondIx.programId.toBase58()).toBe('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
//       expect(secondIx.keys[0].pubkey.toBase58()).toBe(userWallet.toBase58());
//       expect(secondIx.keys[1].pubkey.toBase58()).toBe(userPdaTokenB.toBase58());
//       expect(secondIx.keys[2].pubkey.toBase58()).toBe(userPda.toBase58());

//       // Checkpoint 2: Should invoke newUser instruction
//       expect(thirdIx.programId.toBase58()).toBe('FqGg2Y1FNxMiGd51Q6UETixQWkF5fB92MysbYogRJb3P');
//       expect(thirdIx.data.subarray(0, 8).toString('base64')).toBe(core.util.sighash(`newUser`).toString('base64'));

//       let hasDepositTokenToUserPdaToDepositTokenX = false;
//       let hasDepositTokenToUserPdaToDepositTokenY = false;
//       let hasInitializePosition = false;
//       let hasAddLiquidityByWeight = false;
//       for (const ix of txs[1]) {
//         // Checkpoint 3: Should invoke depositTokenToUserPdaIx to deposit tokenX
//         hasDepositTokenToUserPdaToDepositTokenX = hasDepositTokenToUserPdaToDepositTokenX ||
//           ix.programId.toBase58() === 'FqGg2Y1FNxMiGd51Q6UETixQWkF5fB92MysbYogRJb3P' &&
//           ix.data.subarray(0, 8).toString('base64') === core.util.sighash(`depositTokenToUserPda`).toString('base64') &&
//           ix.keys[2].pubkey.toBase58() === userWallet.toBase58() &&
//           ix.keys[3].pubkey.toBase58() === userTokenA.toBase58() &&
//           ix.keys[4].pubkey.toBase58() === userPdaTokenA.toBase58();

//         // Checkpoint 4: Should invoke depositTokenToUserPdaIx to deposit tokenY
//         hasDepositTokenToUserPdaToDepositTokenY = hasDepositTokenToUserPdaToDepositTokenY ||
//           ix.programId.toBase58() === 'FqGg2Y1FNxMiGd51Q6UETixQWkF5fB92MysbYogRJb3P' &&
//           ix.data.subarray(0, 8).toString('base64') === core.util.sighash(`depositTokenToUserPda`).toString('base64') &&
//           ix.keys[2].pubkey.toBase58() === userWallet.toBase58() &&
//           ix.keys[3].pubkey.toBase58() === userTokenB.toBase58() &&
//           ix.keys[4].pubkey.toBase58() === userPdaTokenB.toBase58();

//         // Checkpoint 5: Should invoke meteoraDynamicCpi to invoke initializePosition of Meteora
//         hasInitializePosition = hasInitializePosition ||
//           ix.programId.toBase58() === 'FqGg2Y1FNxMiGd51Q6UETixQWkF5fB92MysbYogRJb3P' &&
//           ix.data.subarray(0, 8).toString('base64') === core.util.sighash(`meteoraDynamicCpi`).toString('base64') &&
//           ix.data.subarray(12, 20).toString('base64') === core.util.sighash(`initializePosition`).toString('base64');

//         // Checkpoint 6: Should invoke meteoraDynamicCpi to invoke addLiquidityByWeight of Meteora 
//         hasAddLiquidityByWeight = hasAddLiquidityByWeight ||
//           ix.programId.toBase58() === 'FqGg2Y1FNxMiGd51Q6UETixQWkF5fB92MysbYogRJb3P' &&
//           ix.data.subarray(0, 8).toString('base64') === core.util.sighash(`meteoraDynamicCpi`).toString('base64') &&
//           ix.data.subarray(12, 20).toString('base64') === core.util.sighash(`addLiquidityByWeight`).toString('base64');
//       }
//       expect(hasDepositTokenToUserPdaToDepositTokenX).toBe(true);
//       expect(hasDepositTokenToUserPdaToDepositTokenY).toBe(true);
//       expect(hasInitializePosition).toBe(true);
//       expect(hasAddLiquidityByWeight).toBe(true);
//     }, 20_000);
//   });
// });

function isPublicKey(address: string): boolean {
  try {
    new web3.PublicKey(address);
    return true;
  } catch {
    return false;
  }
}

function isInteger(value: string): boolean {
  return String(parseInt(value)) === value;
}